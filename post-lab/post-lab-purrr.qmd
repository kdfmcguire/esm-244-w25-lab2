---
title: "Post lab: Purrr"
author: "Kylie McGuire"
date: "2025-1-19"
format: 
  html:
    embed-resources: true
    code-fold: true
execute:
  warning: false
  eval: false
---

```{r}

library(tidyverse)
library(gapminder)
```

## Purrr Definitions

1. In your own words, describe what the map functions from the `purrr` package accomplish?
 - map functions apply a specied function to each element of a list and return vector of a specific data type
 
2. What data type do the following functions return?

  + `map()`
    - list
  + `map_chr()`
    - character (string)
  + `map_dbl()`
    - double (numeric)
  + `map_df()`
    - dataframe
  + `map_lgl()`
    - logical

3. If I have a dataset where I want to iterate over 4 variables that are changing, which of the following functions would I use?

  a. `map()`
  b. `map2()`
  c. `pmap()`
  d. `mutate()`

  - C. pmap functions "iterate over multiple arguments simultaneously", or 'in parallel'
  
## Purrr Coding

1. Format the out of order code into the correct order for it to run

```{r, eval=FALSE}
janitor::clean_names() |> 
mutate(reg=map(.x=data, ~lm(life_exp~pop+gdp_per_cap+year,data=.x))) |> 
output <- gapminder |> 
mutate(coeff=map(.x=reg, ~coefficients(.x)))
nest(.by=continent) |> 
```

```{r}
output <- gapminder |> 
  janitor::clean_names() |>
  nest(.by=continent) |>
  mutate(reg=map(.x=data, ~lm(life_exp~pop+gdp_percap+year,data=.x))) |> 
  mutate(coeff=map(.x=reg, ~coefficients(.x)))
```

2. Purr is excellent and speeding up simulation processes without having to rely on for loops. For example we could see how different production elasticities (a,b) benefit an economy with known capital (k) and labor (l). Run through the code below. Fix the error in `try1`. Which output would you prefer between a fixed `try1` and `try2`?


```{r,eval=FALSE}
parameters=expand_grid(a=seq(0.1,0.8,by=.1),b=seq(0.2,1,by=.1),k=4,l=2)

cobb<-function(a,b,k,l){
  out=k^a*l^b
  return(as.data.frame(out))
}

#try1<-map2_df(.x=parameters$a,.y=parameters$b,~cobb(.x,.y))

try1<-map2_df(.x=parameters$a,.y=parameters$b,~cobb(.x, .y, k=4, l=2))

try2<-pmap_df(parameters,cobb)

```

- try2 is cleaner, and would work for any combination of sequences and constants

## Purrr in action

We want to plot 6 graphs for the top 6 most expensive child care states with data from 2008 to 2018. Each graph will be child care costs on the y-axis with two lines for median weekly infant and preschool care against the x axis of years. Modify the accompanying `plot_function` to be suitable for a `purrr` map. Create your own mapping and then use cowplot, ggarrange, or gridarrange to show all the plots on one figure. 

```{r}

# Run this code chunk to download data and get it in a good format
childcare_costs <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2023/2023-05-09/childcare_costs.csv') 

counties <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2023/2023-05-09/counties.csv')

cc_clean<-childcare_costs |> 
  select(county_fips_code,mc_infant,mc_preschool,study_year) |> 
  full_join(counties)

top_6 <- cc_clean |>  
  group_by(state_name) |> 
  summarize(num=sum(is.na(mc_infant)),
            avg_cost=mean(mc_infant,na.rm=TRUE)) |> 
  filter(num==0) |> 
  top_n(6)

cc_plot_df <- cc_clean |> 
  filter(state_name %in% top_6$state_name) |> 
  group_by(state_name,study_year) |> 
  summarize(avg_infant=mean(mc_infant,na.rm=T),
            avg_pre=mean(mc_preschool,na.rm=T)) |> 
  pivot_longer(cols=c("avg_infant","avg_pre"),
               names_to = "childcare",
               values_to = "cost")
  
```

```{r,eval=FALSE}
#Students edit this code chunk

plot_function <- function(df, state){  #Fill in the ...
  p <- df|>  #Fill in xxx
    ggplot(aes(x = study_year, y = cost, color = childcare)) +
    labs(x = "Year", y = "Childcare Cost", color = "Childcare Type", title = state) +
    
    geom_line(linewidth=2) +
    scale_x_continuous(breaks=seq(2008,2018,by=2),labels = seq(2008,2018,by=2))+
    scale_color_manual(values=c("forestgreen","purple"),breaks=c("avg_infant","avg_pre"),labels=c("Infant","Preschool"),name="")+
    theme_bw()+
    theme(plot.title = element_text(hjust = 0.5))
  return(p)
}
```

```{r}
cc_plots <- cc_plot_df |> #start with the dataframe of all 6 states, study years, childcare types, and costs
  nest() |> 
  #nests each state's data into a tibble and stores the tibbles in a column called "data". note: cc_plots is already grouped by state_name.
  mutate(plot=map2(.x=data, .y=state_name, .f=plot_function)) 
  #adds a column called "plots" that contains the ggplot list generated by plot_function
```

Copied from solutions, since we have not leanred how to use ggarrange yet
```{r}
ggpubr::ggarrange(plotlist=plot_list$plots, ncol=2, nrow=3, common.legend = TRUE, legend="bottom")

```


### Complete the following tasks with purrr

1. Generate 10 random samples from a normal distribution where the mean and standard deviation increase from 1 to 10 and  to 20. Hint: Make sure the sequences are of the same length by setting the length.out=11 argument in seq()
```{r}

```


2. Use purrr to quickly return the class of every column from the `gapminder` dataset as characters

```{r}
map_chr(gapminder, class)
```



